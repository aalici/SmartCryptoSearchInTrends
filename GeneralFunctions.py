# THIS SCRIPT IS AUTOGENERATED FROM GeneralFunctions.ipynb. 


#export
#General imports
import pandas as pd
import os
import pickle
import exporter
from datetime import datetime, timedelta


#email sending
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

#logging
import logging
# Gets or creates a logger
logger = logging.getLogger(__name__)  
# set log level
logger.setLevel(logging.INFO)
# define file handler and set formatter
file_handler = logging.FileHandler('logfile.log')
formatter    = logging.Formatter('%(asctime)s : %(levelname)s : %(name)s : %(message)s')
file_handler.setFormatter(formatter)
# add file handler to logger
logger.addHandler(file_handler)

#StringMatch
from fuzzywuzzy import fuzz

#Google Trends & Tweeter  
from pytrends.request import TrendReq
import tweepy

#environment variables
from dotenv import load_dotenv
load_dotenv()


# export
def f_send_mail(mail_content=None, 
                mail_to=None,
                mail_subject=None):
    if mail_to is None:
        mail_to = 'ali.alici84@gmail.com'
        
    if mail_content is None:
        mail_content = 'Just try mail sending logic. No specific content is set.'    
        
    if mail_subject is None:
        mail_subject = 'Test Mail from App'    

    logger.info('Try to send email to {x}'.format(x=mail_to))
    #mail_content = '''Hello,
    #This is a simple mail. There is only text, no attachments are there The mail is sent using Python SMTP library.
    #Thank You
    #'''
    
    #The mail addresses and password
    sender_address = 'cuneytsolmazto@gmail.com'
    sender_pass = os.environ.get('GMAIL_API_SECRET')
    receiver_address = mail_to
    
    message = MIMEMultipart()
    message['From'] = sender_address
    message['To'] = receiver_address
    message['Subject'] = mail_subject   #The subject line
    #The body and the attachments for the mail
    message.add_header('Content-Type','text/html')
    
    message.attach(MIMEText(mail_content, 'html'))
    try:
        #Create SMTP session for sending the mail
        session = smtplib.SMTP('smtp.gmail.com', 587) #use gmail with port
        session.starttls() #enable security
        session.login(sender_address, sender_pass) #login with mail_id and password
        text = message.as_string()
        session.sendmail(sender_address, receiver_address, text)
        session.quit()
        logger.info('Mail Sent')
    except:
        logger.error('Sent mail has failed !!')
        session.quit()


#export
def connect_tweet():    
    # OAuth process, using the keys and tokens
    consumer_key = os.environ.get('TWEET_CONSUMER_KEY')
    consumer_secret = os.environ.get('TWEET_CONSUMER_SECRET')
    access_token = os.environ.get('TWEET_ACCESS_TOKEN')
    access_token_secret = os.environ.get('TWEET_ACCESS_TOKEN_SECRET')
    logger.info('Try to connect tweeter api')

    try:        
        auth = tweepy.OAuthHandler(consumer_key, consumer_secret)
        auth.set_access_token(access_token, access_token_secret)
        api = tweepy.API(auth)
        logger.info('Successfully connected to tweeter api')
    except:
        logger.error('tweeter connection has failed !!')
        print('ERROR!!!')
        
    return api



def get_tweet_trends_by_loc(v_api, v_loc):
    if v_loc == "TR":
        woeid = 23424969
    elif v_loc == "US":
        woeid = 23424977    

    # fetching the trends
    trends = v_api.trends_place(id = woeid)
    list_tmp = []
    for value in trends:
        for trend in value['trends']:
            list_tmp.append(trend['name'])  
            #print(trend['name'])

    return list_tmp


def get_tweets_from_user(v_api, v_userid):
    # fetching the tweets
    list_tmp = []
    tweets = v_api.user_timeline(screen_name=v_userid, 
                               # 100 is the maximum allowed count
                               count=100,
                               include_rts = False,
                               # Necessary to keep full_text 
                               # otherwise only the first 140 words are extracted
                               #tweet_mode = 'extended'
                               )


    # printing the statuses
    for info in tweets:
        dt_hours_from_now = datetime.now() + timedelta(hours=-72)
        if info.created_at >= dt_hours_from_now: 
            txt = "ID: {id}, Date: {dt}, Text: {txt}".format(id=info.id, dt= info.created_at, txt= info.text )
            list_tmp.append(txt)
            #print("ID: {}".format(info.id))
            #print(info.created_at)
            #print(info.text, end = "\n\n")

    return list_tmp



def tweet_analyze():
    api = connect_tweet()

    tweet_dict = {}
    tweet_dict.update({"TR TREND TOPICS": get_tweet_trends_by_loc(api, "TR")}) 
    tweet_dict.update({"US TREND TOPICS": get_tweet_trends_by_loc(api, "US")}) 
    
    tweetuserid = 'elonmusk'
    tweet_dict.update({"TWEET from " + tweetuserid: get_tweets_from_user(api, tweetuserid)})
    
    return tweet_dict


def match_symbol_with_tweets(v_score=90):

    file = open("coin_list_df.pkl","rb")
    coin_list_df = pickle.load(file)

    dict_tw = tweet_analyze()
    list_tmp=[]
    for index, row in coin_list_df.iterrows():
        for key in dict_tw:
            for trendtopic in dict_tw.get(key):
                name_score = fuzz.token_set_ratio(row["Name"].lower(), trendtopic.lower())
                symbol_score = fuzz.token_set_ratio(row["Symbol"].lower(), trendtopic.lower())
                if name_score > v_score | symbol_score > v_score :
                    list_tmp.append([key, row["Name"], row["Symbol"], trendtopic.lower(), name_score, symbol_score  ])

    return list_tmp



def send_mails_with_matches(v_score_match = None):
    if v_score_match is None:
        v_score = 90
    else:
        v_score = v_score_match
    v_list = match_symbol_with_tweets(v_score)
    df = pd.DataFrame(data = v_list, columns =["Source","Coin", "Symbol", "News", "Score1", "Score2"])
    #return df.to_html() 
    mail_body = df.to_html()
    #for topic in v_list:
    #    mail_body = mail_body + ' $ '.join(topic[0:4]) + '\n'  
    if len(v_list) > 0:
        f_send_mail(mail_content = mail_body)
        print("successfully send mail")
    else:
        logger.info('Does not match anything, so we have nothing to sent!')
        print("Does not match anything, so we have nothing to sent!")
    


# export
if __name__ == "__main__":
    v_list = match_symbol_with_tweets(v_score=90)
    mail_body = ''
    for topic in v_list:
        mail_body = mail_body + ' $ '.join(topic[0:4]) + '\n'  
    if len(v_list) > 0:
        f_send_mail(mail_content = mail_body)
